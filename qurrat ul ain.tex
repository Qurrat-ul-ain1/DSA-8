\documentclass[11pt]{article}            % Report class in 11 points
\parindent0pt  \parskip10pt             % make block paragraphs
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {images/} }
\usepackage{graphicx} %  graphics header file
\begin{document}
\begin{titlepage}
    \centering
  \vfill
    \includegraphics[width=8cm]{uni_logo.png} \\ 
	\vskip2cm
    {\bfseries\Large
	Data Structures and Algorithms \\ ( CS09203 )\\
	
	\vskip2cm
	Lab Report 
	 
	\vskip2cm
	}    

\begin{center}
\begin{tabular}{ l l  } 

Name: & Qurrat-ul-ain  \\ 
Registration \#: & SEU-F16-132 \\ 
Lab Report \#: & 8 \\ 
 Dated:& 28-05-2018\\ 
Submitted To:& Mr. Usman Ahmed\\ 

 %\hline
\end{tabular}
\end{center}
    \vfill
    The University of Lahore, Islamabad Campus\\
Department of Computer Science \& Information Technology
\end{titlepage}


    
    {\bfseries\Large
\centering
	Experiment \# 1 \\

Directed graph
Undirected graph
Weighted graph\\
	
	}    
 \vskip1cm
 \textbf {Objective}\\ The objectives of this lab session are to understand the basic and various operations on directed graph, indirected graph,weighted graph. 
 
 \textbf {Software Tool}\\
1. Code Blocks with GCC compiler\\
2. \\
3. \\

\section{Theory }             Directed Graph:
A directed graph is graph, i.e., a set of objects (called vertices or nodes) that are connected together, where all the edges are directed from one vertex to another. A directed graph is sometimes called a digraph or a directed network.
Undirected graph:
A directed graph is graph, i.e., a set of objects (called vertices or nodes) that are connected together, where all the edges are directed from one vertex to another. A directed graph is sometimes called a digraph or a directed network.
Weighted graph:
 A graph having a weight, or number, associated with each edge. Some algorithms require all weights to be nonnegative, integral, positive, etc. Also known as edge-weighted graph.

\section{Task}  
\subsection{Procedure: Task 1 }     

\begin{figure*}
\centering
  \includegraphics[width=12cm,height=6cm,keepaspectratio]{neww.png}
  \caption{output}
    \includegraphics[width=12cm,height=6cm,keepaspectratio]{lab8.png}
\caption{output}
\label{Figure:3}    
\end{figure*}
Write a C++ program to implement all the above described algorithms and display the following menu and ask the user for the desired operation.

\subsection{ }     

\begin{lstlisting}[language=Python]
 
#include <cstdio>
#include <vector>
#include <list>
#include <utility>
#include<iostream>
#include<iomanip>
using namespace std;
class Graph {
private:
      bool** adjMatrix;
      int numVertices;
public:
      Graph(int numVertices) {
            this->numVertices = numVertices;
            adjMatrix = new bool*[numVertices];
            for (int i = 0; i < numVertices; i++) {
                  adjMatrix[i] = new bool[numVertices];
                  for (int j = 0; j < numVertices; j++)
                        adjMatrix[i][j] = false;
          }
    }
 
      void addEdge(int i, int j) {
                  adjMatrix[i][j] = true;
                  adjMatrix[j][i] = true;
    }
 
      void removeEdge(int i, int j) {
                  adjMatrix[i][j] = false;
                  adjMatrix[j][i] = false;
    }
 
      bool isEdge(int i, int j) {
                  return adjMatrix[i][j];
    }

    void toString() {
      for (int i = 0; i < numVertices; i++) {
                  cout << i << " : ";
                  for (int j = 0; j < numVertices; j++)
                        cout << adjMatrix[i][j] << " ";
                  cout << "\n";
      }

    }
 
    ~Graph() {
            for (int i = 0; i < numVertices; i++)
                  delete[] adjMatrix[i];
            delete[] adjMatrix;
    }
};

void PrintMat(int **mat, int n)
{
	int i, j;
 
	cout<<"\n\n"<<setw(4)<<"";
	for(i = 0; i < n; i++)
		cout<<setw(3)<<"("<<i+1<<")";
	cout<<"\n\n";
 
	// Print 1 if the corresponding vertexes are connected otherwise 0.
	for(i = 0; i < n; i++)
	{
		cout<<setw(3)<<"("<<i+1<<")";
		for(j = 0; j < n; j++)
		{
			cout<<setw(4)<<mat[i][j];
		}
		cout<<"\n\n";
	}
}


int main(){
	char w;
	line:
	cout<<"press U for Adding Edges to the Undirected Graph\n";
	cout<<"\npress D for Adding Edges to the Directed Graph \n";
	cout<<"\npress W for Adding Edges to the Weighted Graph\n";
	cout<<"\npress E to Exit\n ";
	cout<<"\nEntre your choice\n";
	cin>>w;
	switch(w){
		case 'u':
		{
			 	 int u,d,w=0,y=0;
       cout<<"how many vertics"<<endl;
       	cin>>u;
       	Graph g(u);
	   while(y!=u){
       	
		   cout<<"add edges "<<endl;
       	cin>>u>>d;
       	g.addEdge(u,w);
       	
       	y++;

	   }
       	g.toString();
		   	   
	   break;
}
	   case'd':
	   	
	   	int i, v, e, j, v1, v2;
 
	cout<<"Enter the number of vertexes of the graph: ";
	cin>>v;
 
	int **graph;
	graph = new int*[v];
 
	for(i = 0; i < v; i++)
	{
		graph[i] = new int[v];
		for(j = 0; j < v; j++)graph[i][j] = 0;
	}
 
	cout<<"\nEnter the number of edges of the graph: ";
	cin>>e;
 
	for(i = 0; i < e; i++)
	{
		cout<<"\nEnter the vertex pair for edge "<<i+1;
		cout<<"\nV(1): ";
		cin>>v1;
		cout<<"V(2): ";
		cin>>v2;
 
		graph[v1-1][v2-1] = 1;
		graph[v2-1][v1-1] = 1;
	}

	PrintMat(graph, v);
    break;

	case 'w':
    {
	    int vertices, edges, v1, v2, weight;

 cout<<"Enter the Number of Vertices -\n";

 cin>>vertices;
cout<<vertices;
cout<<"Enter the Number of Edges -\n";

 cin>>edges;

 vector< list< pair<int, int> > > adjacencyList(vertices + 1);

 cout<<"Enter the Edges V1 -> V2, of weight W\n";

 for (int i = 1; i <= edges; ++i) {

cin>> v1, v2, weight;


 adjacencyList[v1].push_back(make_pair(v2, weight));

 }

 cout<<"\nThe Adjacency List-\n";


 for (int i = 1; i < adjacencyList.size(); ++i) {

 cout<<"adjacencyList ", i;

 list< pair<int, int> >::iterator itr = adjacencyList[i].begin();

 while (itr != adjacencyList[i].end()) {

 cout<< (*itr).first, (*itr).second;

 ++itr;

 }

cout<<"\n";

 }break;
 
}
goto line;
   case 'e':
	exit;
}

 return 0;}


\end{lstlisting}

\section{Conclusion}  
In todays lab we have discussed how we  can create doubly linked list and how can we traverse and implement it on computer.

 
\end{document}                          % The required last line
